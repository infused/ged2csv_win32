unit Main;

interface

uses
  Windows, Messages, SysUtils, Classes, Controls, Forms,
  Dialogs, StdActns, Menus, ActnList, StdCtrls, ComCtrls, ToolWin, ExtCtrls,
  Buttons, Gauges, ActnMan, ActnCtrls, ActnMenus, ImgList, DB,
  KDaoTable, KDaoDataBase, DaoApi, ActnColorMaps, XPMan,
  XPStyleActnCtrls, LMDCustomComponent, LMDOneInstance,
  LMDBaseControl, LMDBaseGraphicControl, LMDGraphicControl, LMDBaseMeter,
  LMDCustomProgress, LMDProgress, LMDIniCtrl, Printers,
  LMDProgressFill, LMDCustomProgressFill, ExtActns, IdBaseComponent,
  IdComponent, IdTCPConnection, IdTCPClient, IdHTTP, LMDContainerComponent,
  lmdmsg, IdCoder, idException, IdCoder3to4, IdCoderUUE, IdFTP,
  TFlatMemoUnit, IdAntiFreezeBase, IdAntiFreeze, LMDCustomControl,
  LMDCustomPanel, LMDCustomBevelPanel, LMDCustomStatusBar, LMDStatusBar,
  LMDBaseGraphicButton, LMDCustomSpeedButton, LMDSpeedButton, LMDBaseLabel,
  LMDCustomSimpleLabel, LMDSimpleLabel, IdIntercept, IdLogBase, IdLogFile,
  OleServer, Variants, LMDControl;

type
  TfrmMain = class(TForm)
    ActionManager1: TActionManager;
    FileOpen1: TFileOpen;
    FileExit1: TFileExit;
    EditCopy1: TEditCopy;
    FileSave1: TAction;
    FilePrefs1: TAction;
    ActionMainMenuBar1: TActionMainMenuBar;
    ActionToolBar1: TActionToolBar;
    HelpAbout1: TAction;
    HelpContents1: THelpContents;
    Memo1: TFlatMemo;
    XPColorMap1: TXPColorMap;
    XPGlyphs: TImageList;
    LMDOneInstance1: TLMDOneInstance;
    EditSelectAll1: TEditSelectAll;
    IniControl: TLMDIniCtrl;
    BrowseURL1: TBrowseURL;
    FilePageSetup1: TFilePageSetup;
    FilePrintSetup1: TFilePrintSetup;
    HelpTopicSearch1: THelpTopicSearch;
    Update: TAction;
    HTTP1: TIdHTTP;
    FilePrint1: TPrintDlg;
    Encoder: TIdEncoderUUE;
    Decoder: TIdDecoderUUE;
    UpMySQL: TAction;
    FTP: TIdFTP;
    IdAntiFreeze1: TIdAntiFreeze;
    StatusBar: TLMDStatusBar;
    Gauge1: TLMDProgress;
    btnAbort: TLMDSpeedButton;
    lblStatus: TLMDSimpleLabel;
    FTPLogFile: TIdLogFile;
    HTTPLogFile: TIdLogFile;
    FileExportExcel: TAction;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure HelpAbout1Execute(Sender: TObject);
    procedure FileOpen1Accept(Sender: TObject);
    procedure FileSave1Execute(Sender: TObject);
    procedure FilePrefs1Execute(Sender: TObject);
    procedure HelpContents1Execute(Sender: TObject);
    procedure UpdateExecute(Sender: TObject);
    procedure FilePrint1Accept(Sender: TObject);
    procedure UpMySQLExecute(Sender: TObject);
    procedure HelpTopicSearch1Execute(Sender: TObject);
    procedure btnAbortClick(Sender: TObject);
  public
    procedure GaugeSetup(const Vis: boolean; const Min: integer = 0; const Max:
      integer = 100);
    procedure GaugeProgress(const I: integer);
  end;

type
  T2DStringArray = array of array of string;

procedure UpdateStatusLog(const Text: string);
procedure SavingEnabled(Status: boolean);
procedure SaveAsDF();
procedure SaveAsMDB();
procedure OpenPrefs();
procedure SaveArrayToFile(const FilePath, FileName: string; const TheArray:
  T2DStringArray);
procedure UpdateStatusBar(const PanelNum: integer; const PanelText: string);
procedure CalculateStats;

var
  { Declare global variables }
  frmMain: TfrmMain;
    // Link the frmMain form to the TfrmMain class declared above
  GedcomLines: TStringList; // TStringList to store all lines from gedcom file
  GedcomFileName: string;
    // Full path and filename of the gedcom file to be parsed
  FactNum: integer; // Unique fact number generated by ged2csv
  IndivArray: T2DStringArray;
  IndevIndex: integer;
  FactArray: T2DStringArray;
  FactIndex: integer;
  RelatArray: T2DStringArray;
  RelatIndex: integer;
  FamArray: T2DStringArray;
  FamIndex: integer;
  NoteArray: T2DStringArray;
  NoteIndex: integer;
  SourceArray: T2DStringArray;
  SourceIndex: integer;
  CitationArray: T2DStringArray;
  CitationIndex: integer;
  ChildArray: T2DStringArray;
  ChildIndex: integer;

  DefaultArrayInc: integer;
  AppVersion: string; { Version string from executable }
  RegisteredTo: string;
  AbortProc: boolean;

  { General Options }
  RemoveQuotes: boolean;
  ParaSep: string;
  Wrap: boolean;
  WrapCol: integer;
  CalcStats: boolean;

  { Delimited File Options }
  DFOutputDir: string;
  IndividualListFile: string;
  FamilyListFile: string;
  RelationListFile: string;
  FactListFile: string;
  NoteListFile: string;
  SourceListFile: string;
  CitationListFile: string;
  ChildListFile: string;
  SaveToDF: boolean;
  SaveDFAfterProc: boolean;

  { MS Access DB Options }
  IndividualTbl: string;
  FamilyTbl: string;
  RelationTbl: string;
  FactTbl: string;
  NoteTbl: string;
  SourceTbl: string;
  CitationTbl: string;
  ChildTbl: string;
  SaveToMDB: boolean;
  MDBFilename: string;
  MDBVersion: string;

  { PHP MySQL Options }
  FTPServer: string;
  FTPUser: string;
  FTPPassword: string;
  FTPPasswordSave: boolean;
  FTPPath: string;
  HTTPServer: string;
  MySQLDB: string;
  MySQLUSer: string;
  MySQLPassword: string;
  MySQLPasswordSave: boolean;
  MySQLFactTbl: string;
  MySQLFamilyTbl: string;
  MySQLIndividualTbl: string;
  MySQLNoteTbl: string;
  MySQLRelationTbl: string;
  MySQLSourceTbl: string;
  MySQLCitationTbl: string;
  MySQLChildTbl: string;

const
  { Declare global constants }
  CRLF = #13#10;
  VarsFile = 'ged2csv_variables.php';
  FncsFile = 'ged2csv_functions.php';

implementation

uses
  ged55utils, About, Prefs, Ini, StrUtils, connection;
{$R *.dfm}

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.FormCreate(Sender: TObject);
const
  PrmHelpFileName = 'ged2csv.hlp';

begin
  Application.ShowHint := True; { Enable hints }
  GedcomLines := TStringList.Create;
  GetPrefsFromIni(); { Load preferences }
  AppVersion := frmAbout.GetBuildInfoString; { Get version string from exe}
  RegisteredTo := GetEnvironmentVariable('VPSTATUS');
  Application.helpFile := ExtractFilePath(Application.ExeName) +
    PrmHelpFileName;

  { Init Memo }
  with Memo1.Lines do
  begin
    Clear;
    Add('Ged2Csv');
    Add('Version ' + AppVersion);
    Add('Copyright 2001-2003 Keith Morrison / Infused Solutions');
    Add('');
    if RegisteredTo = '' then
      RegisteredTo := 'UNPROTECTED';
    Add('Registered to: ' + RegisteredTo);
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.FormDestroy(Sender: TObject);
begin
  GedcomLines.Free;
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.HelpAbout1Execute(Sender: TObject);
begin
  frmAbout.ShowModal;
end;

{ ---------------------------------------------------------------------------- }

procedure OpenPrefs();
begin
  frmPrefs.ShowModal;
end;

{ ---------------------------------------------------------------------------- }

procedure SavingEnabled(Status: boolean);
begin
  frmMain.FileSave1.Enabled := Status;
  frmMain.UpMySQL.Enabled := Status;
  frmMain.FileExportExcel.Enabled := Status;

end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.FileOpen1Accept(Sender: TObject);
begin
  if FileOpen1.ExecuteResult then
  begin
    GedcomFileName := FileOpen1.Dialog.FileName;
    ParseGedcom(); //Call the ParseGedcom procedure (in ged55utils)
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure SaveAsDF();
begin
  { Set hourglass cursor }
  Screen.Cursor := crHourGlass;

  { Update StatusBar }
  UpdateStatusBar(1, 'Status: Saving Delimited Files');

  { Define files }
  if DFOutputDir = '' then
    DFOutputDir := extractfilepath(Application.ExeName);
  UpdateStatusLog('Output Directory: ' + DFOutputDir);

  { Write date to files }
  UpdateStatusLog('Saving ' + DFOutputDir + IndividualListFile);
  SaveArrayToFile(DFOutputDir, IndividualListFile, IndivArray);
  UpdateStatusLog('Saving ' + DFOutputDir + FamilyListFile);
  SaveArrayToFile(DFOutputDir, FamilyListFile, FamArray);
  UpdateStatusLog('Saving ' + DFOutputDir + RelationListFile);
  SaveArrayToFile(DFOutputDir, RelationListFile, RelatArray);
  UpdateStatusLog('Saving ' + DFOutputDir + FactListFile);
  SaveArrayToFile(DFOutputDir, FactListFile, FactArray);
  UpdateStatusLog('Saving ' + DFOutputDir + NoteListFile);
  SaveArrayToFile(DFOutputDir, NoteListFile, NoteArray);
  UpdateStatusLog('Saving ' + DFOutputDir + SourceListFile);
  SaveArrayToFile(DFOutputDir, SourceListFile, SourceArray);
  UpdateStatusLog('Saving ' + DFOutputDir + CitationListFile);
  SaveArrayToFile(DFOutputDir, CitationListFile, CitationArray);
  UpdateStatusLog('Saving ' + DFOutputDir + ChildListFile);
  SaveArrayToFile(DFOutputDir, ChildListFile, ChildArray);
  UpdateStatusLog('Save complete.');
  UpdateStatusLog('');

  { Update StatusBar }
  UpdateStatusBar(1, 'Status:');

  { Restore default cursor }
  Screen.Cursor := crDefault;
end;

{ ---------------------------------------------------------------------------- }

procedure SaveAsMDB();
var
  Database1: TKADaoDatabase;
  Table1: TKADaoTable;
  TableMgr1: TKADaoTableManager;
  QueryStr: string;

  { Declare local procedure to save array contents to table }
  procedure SaveArrayToTable(const TheTableName: string; const TheArray:
    T2DStringArray);
  var
    I: integer;
    J: integer;
  begin
    frmMain.GaugeSetup(True, 0, pred(length(TheArray)));
    UpdateStatusLog('Inserting ' + inttostr(length(TheArray)) + ' records into '
      + TheTableName);
    UpdateStatusBar(1, 'Status: Inserting records into ' + TheTableName);
    with Table1 do
    begin
      TableName := TheTableName;
      Active := True;
      for I := 0 to pred(length(TheArray)) do
      begin
        Append;
        for J := 0 to pred(length(TheArray[I])) do
        begin
          Fields[J].AsString := TheArray[I, J];
        end;
        Post;
        frmMain.GaugeProgress(I);
        Application.ProcessMessages;
      end;
    end;
    Table1.Active := False;
    UpdateStatusBar(1, 'Status:');
    frmMain.GaugeSetup(False);
  end;

begin
  { Delete old MDB file }
  if fileexists(MDBFilename) then
  begin
    UpdateStatusLog(MDBFilename + ' exists and will be overwritten!');
    if DeleteFile(MDBFilename) = False then
    begin
      UpdateStatusLog('Unable to delete ' + MDBFilename +
        '. Another application may have it open.');
      UpdateStatusLog('Aborting save to MS Access database');
      exit;
    end;
  end;

  { Set hourglass cursor }
  Screen.Cursor := crHourGlass;

  { Initialize MS Access DB components }
  Database1 := TKADaoDatabase.Create(nil);
  with Database1 do
  begin
    UserName := 'Admin';
    Password := '';
    DatabaseType := 'Access';
    if MDBVersion = '30' then
      UpdateStatusLog('Creating Access 97 database: ' + MDBFilename)
    else
      UpdateStatusLog('Creating Access 2000/2002 database: ' + MDBFilename);
    CreateAccessDatabaseEx2(MDBFilename, dbLangGeneral, '', MDBVersion, False);
  end;
  { Update Status Log }
  UpdateStatusLog('Creating Access Database ' + MDBFilename);

  { Connect to DB and create tables }
  with Database1 do
  begin
    Database := MDBFilename;
    Connected := True;
  end;
  TableMgr1 := TKADaoTableManager.Create(Database1);
  Table1 := TKADaoTable.Create(Database1);
  with Table1 do
  begin
    Database := Database1;
    CacheBlobs := False;
    CacheMemos := False;
    UseRecordCount := True;
    UseGetRecNo := False;
  end;

  { Create Fact table and insert records}
  with TableMgr1 do
  begin
    TableName := FactTbl;
    with FieldDefs do
    begin
      Clear;
      Add('IndFamKey', ftString, 20, False);
      Add('Type', ftString, 35, False);
      Add('Date', ftString, 35, False);
      Add('Place', ftString, 120, False);
      Add('Factkey', ftString, 20, False);
    end;
    CreateTable;
    SaveArrayToTable(FactTbl, FactArray);

    { Create Family table and insert records}
    TableName := FamilyTbl;
    with FieldDefs do
    begin
      Clear;
      Add('FamKey', ftString, 20, False);
      Add('Spouse1', ftString, 20, False);
      Add('Spouse2', ftString, 20, False);
      Add('BeginStatus', ftString, 120, False);
      Add('EndStatus', ftString, 120, False);
      Add('NoteKey', ftString, 20, False);
    end;
    CreateTable;
    SaveArrayToTable(FamilyTbl, FamArray);

    { Create Individual table and insert records}
    TableName := IndividualTbl;
    with FieldDefs do
    begin
      Clear;
      Add('IndKey', ftString, 20, False);
      Add('Title', ftString, 120, False);
      Add('Surname', ftString, 120, False);
      Add('GivenName', ftString, 120, False);
      Add('Aka', ftString, 120, False);
      Add('Sex', ftString, 7, False);
      Add('NoteKey', ftString, 20, False);
    end;
    CreateTable;
    SaveArrayToTable(IndividualTbl, IndivArray);

    { Create Note table and insert records}
    TableName := NoteTbl;
    with FieldDefs do
    begin
      Clear;
      Add('NoteKey', ftString, 20, False);
      Add('Text', ftMemo, 0, False);
    end;
    CreateTable;
    SaveArrayToTable(NoteTbl, NoteArray);

    { Create Relation table and insert records}
    TableName := RelationTbl;
    with FieldDefs do
    begin
      Clear;
      Add('IndKey', ftString, 20, False);
      Add('FamKey', ftString, 20, False);
    end;
    CreateTable;
    SaveArrayToTable(RelationTbl, RelatArray);

    { Create Master Source table and insert records}
    TableName := SourceTbl;
    with FieldDefs do
    begin
      Clear;
      Add('SrcKey', ftString, 20, False);
      Add('Text', ftMemo, 0, False);
      Add('NoteKey', ftString, 20, False);
    end;
    CreateTable;
    SaveArrayToTable(SourceTbl, SourceArray);

    { Create Source Citation table and insert records}
    TableName := CitationTbl;
    with FieldDefs do
    begin
      Clear;
      Add('FactKey', ftString, 20, False);
      Add('SrcKey', ftString, 20, False);
      Add('Source', ftMemo, 0, False);
    end;
    CreateTable;
    SaveArrayToTable(CitationTbl, CitationArray);

    { Create Child table and insert records}
    TableName := ChildTbl;
    with FieldDefs do
    begin
      Clear;
      Add('Famkey', ftString, 20, False);
      Add('IndKey', ftString, 20, False);
    end;
    CreateTable;
    SaveArrayToTable(ChildTbl, ChildArray);

  end;

  { Create Place Search (All Facts) query }
  QueryStr := 'SELECT ' + IndividualTbl + '.Surname, ' + IndividualTbl +
    '.GivenName, ' + FactTbl +
    '.Type,';
  QueryStr := QueryStr + FactTbl + '.Date, ' + FactTbl + '.Place FROM ' +
    IndividualTbl + ' ';
  QueryStr := QueryStr + 'INNER JOIN ' + FactTbl + ' ON ' + IndividualTbl +
    '.IndKey = ' + FactTbl +
    '.IndFamKey ';
  QueryStr := QueryStr + 'WHERE (((' + FactTbl +
    '.Place) Like "*" & [Place: ] & "*")) ';
  QueryStr := QueryStr + 'ORDER BY ' + IndividualTbl + '.Surname, ' +
    IndividualTbl + '.GivenName, '
    + FactTbl + '.Type;';
  UpdateStatusLog('Creating Place Search (All Facts) query');
  Database1.CreateQueryDef('Place Search (All Facts)', QueryStr);

  QueryStr := 'SELECT ' + IndividualTbl + '.Surname, ' + IndividualTbl +
    '.GivenName, ' + FactTbl +
    '.Type,';
  QueryStr := QueryStr + FactTbl + '.Date, ' + FactTbl + '.Place FROM ' +
    IndividualTbl + ' ';
  QueryStr := QueryStr + 'INNER JOIN ' + FactTbl + ' ON ' + IndividualTbl +
    '.IndKey = ' + FactTbl +
    '.IndFamKey ';
  QueryStr := QueryStr + 'WHERE (((' + FactTbl + '.Type)="Birth") AND ((' +
    FactTbl +
    '.Place) Like "*" & [Place: ] & "*")) OR (((tblFacts.Type)="Death")) ';
  QueryStr := QueryStr + 'ORDER BY ' + IndividualTbl + '.Surname, ' +
    IndividualTbl + '.GivenName, '
    + FactTbl + '.Type;';
  UpdateStatusLog('Creating Place Search (Birth/Death) query');
  Database1.CreateQueryDef('Place Search (Birth/Death)', QueryStr);

  { Clean up after DB components }
  TableMgr1.Free;
  with Database1 do
  begin
    Connected := False;
    Free;
  end;

  { Update Status Log }
  UpdateStatusLog('Save complete.');
  UpdateStatusLog('');

  { Restore default cursor }
  Screen.Cursor := crDefault;
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.FileSave1Execute(Sender: TObject);
begin
  if SaveToDF = True then
  begin
    UpdateStatusLog('Saving to delimited files...');
    SaveAsDF();
  end;
  if SaveToMDB = True then
  begin
    UpdateStatusLog('Saving to MS Access database...');
    SaveAsMDB();
  end;
  if (SaveToDF = False) and (SaveToMDB = False) then
    UpdateStatusLog('No output options have been selected!');
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.FilePrefs1Execute(Sender: TObject);
begin
  OpenPrefs();
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.HelpContents1Execute(Sender: TObject);
const
  HELP_TAB = 15;
  CONTENTS_ACTIVE = -3; {-3 is content, -2 is index, -1 is find }
begin
  Application.HelpCommand(HELP_TAB, CONTENTS_ACTIVE);
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.HelpTopicSearch1Execute(Sender: TObject);
const
  HELP_TAB = 15;
  CONTENTS_ACTIVE = -1; {-3 is content, -2 is index, -1 is find }
begin
  Application.HelpCommand(HELP_TAB, CONTENTS_ACTIVE);
end;

{ ---------------------------------------------------------------------------- }

procedure SaveArrayToFile(const FilePath, FileName: string; const TheArray:
  T2DStringArray);
var
  TempList: TStringList;
  TempStr: string;
  X, Y: integer;
begin
  TempList := TStringList.Create;
  try
    for X := 0 to length(TheArray) - 1 do
    begin
      TempStr := EmptyStr;
      for Y := 0 to length(TheArray[X]) - 1 do
      begin
        if Y < length(TheArray[X]) - 1 then
          TempStr := TempStr + Quote + TheArray[X, Y] + Quote + Delim
        else
          TempStr := TempStr + Quote + TheArray[X, Y] + Quote;
      end; // for Y := 0
      TempList.Append(TempStr);
    end; // for X := 0
    TempList.SaveToFile(FilePath + FileName);
  finally
    TempList.Free;
  end; // try ... finally
end; // procedure SaveArrayToFile

{ ---------------------------------------------------------------------------- }

procedure UpdateStatusBar(const PanelNum: integer; const PanelText: string);
begin
  { update the lbl on the panel 1 }
  if PanelNum = 1 then
  begin
    frmMain.lblStatus.Caption := ' ' + PanelText;
    frmMain.lblStatus.Update;
  end
    { or update the caption on any other panel }
  else
  begin
    frmMain.StatusBar.Panels[PanelNum].Text := ' ' + PanelText;
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure UpdateStatusLog(const Text: string);
begin
  frmMain.Memo1.Lines.Append(Text);
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.GaugeSetup(const Vis: boolean; const Min: integer = 0; const
  Max: integer = 100);
begin
  Gauge1.MinValue := Min;
  Gauge1.MaxValue := Max;
  Gauge1.Visible := Vis;
  Gauge1.Update;
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.GaugeProgress(const I: integer);
begin
  Gauge1.UserValue := I;
  Gauge1.Update;
end;

{ ---------------------------------------------------------------------------- }

procedure CalculateStats;
var
  X: integer;
  Males, Females, Unknowns: integer;
  MalesP, FemalesP, UnknownsP: string;
  Sex: string;
  Surnames: integer;
  TmpList: TStringList;
begin
  { Initialize variables/lists }
  Males := 0;
  Females := 0;
  Unknowns := 0;
  TmpList := TStringList.Create;
  TmpList.Sorted := True;
  TmpList.Duplicates := dupIgnore;

  try
    { Calculate Sex Statistics }
    for X := 0 to length(IndivArray) - 1 do
    begin
      Sex := IndivArray[X, 5];
      if Sex = 'M' then
        inc(Males);
      if Sex = 'F' then
        inc(Females);
      if Sex = 'U' then
        inc(Unknowns);
    end;
    MalesP := formatfloat('0.00', (Males / length(IndivArray) * 100));
    FemalesP := formatfloat('0.00', (Females / length(IndivArray) * 100));
    UnknownsP := formatfloat('0.00', (Unknowns / length(IndivArray) * 100));

    { Calculate Surname Statistics }
    TmpList.Clear;
    for X := 0 to length(IndivArray) - 1 do
    begin
      TmpList.Add(IndivArray[X, 2]);
    end;
    Surnames := TmpList.Count;

    { Display Database Statistics }
    UpdateStatusLog('Database Statistics');
    UpdateStatusLog('---------------------------------------');
    UpdateStatusLog('Individuals:' + inttostr(length(IndivArray)));
    UpdateStatusLog('  Males:' + inttostr(Males) + ' (' + MalesP + '%)');
    UpdateStatusLog('  Females:' + inttostr(Females) + ' (' + FemalesP + '%)');
    UpdateStatusLog('  Unknown:' + inttostr(Unknowns) + ' (' + UnknownsP +
      '%)');
    UpdateStatusLog('Unique Surnames:' + inttostr(Surnames));
    UpdateStatusLog('Families: ' + inttostr(length(FamArray)) + ' records');
    UpdateStatusLog('Master Sources: ' + inttostr(length(SourceArray)) +
      ' records');
    UpdateStatusLog('Source Citations: ' + inttostr(length(CitationArray)) +
      ' records');
    UpdateStatusLog('Relations: ' + inttostr(length(RelatArray)) + ' records');
    UpdateStatusLog('Facts: ' + inttostr(length(FactArray)) + ' records');
    UpdateStatusLog('Notes: ' + inttostr(length(NoteArray)) + ' records');
    UpdateStatusLog('Children: ' + inttostr(length(ChildArray)) + ' records');
    UpdateStatusLog('');
  finally
    TmpList.Free;
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.UpdateExecute(Sender: TObject);
var
  Response: string;
begin
  UpdateStatusLog('Checking for available updates...');
  UpdateStatusBar(1, 'Status: Checking for available updates...');
  HTTP1.HandleRedirects := True;
  try
    begin
      Response :=
        HTTP1.Get('http://www.infused-solutions.com/software/ged2csv/latest.txt');
      if Response > AppVersion then
      begin
        UpdateStatusLog('An update (' + Response +
          ') is available for download...');
        BrowseURL1.URL := 'http://www.infused.org/software/ged2csv/';
        BrowseURL1.Execute;
      end
      else if Response < AppVersion then
      begin
        UpdateStatusLog('You are running a newer version (' + AppVersion + ')');
      end
      else if Response = AppVersion then
      begin
        UpdateStatusLog('You are running the latest version (' + AppVersion +
          ')');
      end;
    end
  except
    begin
      LMDMessageDlg('There was a problem checking for updates.  Please try again later.', mtError,
        [mbOK], 0);
      UpdateStatusLog('There was a problem checking for updates.  Please try again later.');
    end
  end;
  UpdateStatusBar(1, 'Status:');
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.FilePrint1Accept(Sender: TObject);
var
  I: integer;
  YPos: integer; { Y Pen Position }
  YInc: integer; { Y Pen Position Increment }
  XPos: integer; { X Pen Position }
begin
  with Printer do
  begin
    BeginDoc;
    with Canvas.Font do
    begin
      Name := 'Courier New';
      PixelsPerInch := GetDeviceCaps(Printer.Canvas.Handle, LOGPIXELSX);
      XPos := trunc(FilePageSetup1.Dialog.MarginLeft * PixelsPerInch / 1000);
      YPos := trunc(FilePageSetup1.Dialog.MarginTop * PixelsPerInch / 1000);
    end;
    YInc := Canvas.TextHeight('X');
    for I := 0 to pred(Memo1.Lines.Count) do
    begin
      Canvas.TextOut(XPos, YPos, Memo1.Lines.Strings[I]);
      inc(YPos, YInc);
    end;
    EndDoc;
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.UpMySQLExecute(Sender: TObject);
var
  X: integer;
  LastError: string;
  LastResp: string;
  PostData: TStringList;
  Vars: TStringList;
begin
  btnAbort.Visible := True;
  Application.ProcessMessages;
  PostData := TStringList.Create;
  Vars := TStringList.Create;
  Vars.Add('<?php');
  Vars.Add('$database = "' + MySQLDB + '";');
  Vars.Add('$username = "' + MySQLUser + '";');
  Vars.Add('$password = "' + MySQLPassword + '";');
  Vars.Add('?>');
  Vars.SaveToFile(ExtractFilePath(Application.ExeName) + 'script2.php');
  UpdateStatusLog('Connecting to ' + FTPServer + '...');
  UpdateStatusBar(1, 'Status: Connecting to ' + FTPServer + '...');
  with FTP do
  begin
    Host := FTPServer;
    Username := FTPUser;
    Password := FTPPassword;
    try
      try
        { Connect to FTP server and change directory }
        Connect(True);
        if AbortProc = True then
          exit;
        if FTPPath <> '' then
        begin
          UpdateStatusLog('Changing directory to ' + FTPPath + '...');
          UpdateStatusBar(1, 'Status: Changing directory to ' + FTPPath +
            '...');
          ChangeDir(FTPPath);
        end;
        if AbortProc = True then
          exit;

        { Upload scripts }
        UpdateStatusLog('Uploading ' + VarsFile + '...');
        UpdateStatusBar(1, 'Status: Uploading ' + VarsFile + '...');
        Put(ExtractFilePath(Application.ExeName) + 'script2.php', VarsFile,
          False);
        DeleteFile(ExtractFilePath(Application.ExeName) + 'script2.php');
        if AbortProc = True then
          exit;
        UpdateStatusLog('Uploading ' + FncsFile + '...');
        UpdateStatusBar(1, 'Status: Uploading ' + FncsFile + '...');
        Put(ExtractFilePath(Application.ExeName) + 'script.php', FncsFile,
          False);
        if AbortProc = True then
          exit;

        { Disconnect from FTP Server }
        UpdateStatusLog('Disconnecting from ' + FTPServer + '...');
        UpdateStatusBar(1, 'Status: Disconnecting from ' + FTPServer + '...');
        Disconnect;
        if AbortProc = True then
          exit;

        { Create citation table }
        UpdateStatusLog('Creating citation table...');
        UpdateStatusBar(1, 'Status: Creating citation table...');
        PostData.Clear;
        PostData.Add('action=create_table_citation');
        PostData.Add('table=' + MySQLCitationTbl);
        LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
          PostData);
        if LastResp <> '1' then
        begin
          LastError := 'Error creating citation table';
          exit;
        end;
        if AbortProc = True then
          exit;

        { Upload citation data }
        if length(CitationArray) > 0 then
        begin
          UpdateStatusLog('Uploading citation records...');
          UpdateStatusBar(1, 'Status: Uploading citation records...');
          GaugeSetup(True, 0, length(CitationArray));
          for X := 0 to length(CitationArray) - 1 do
          begin
            UpdateStatusBar(1, 'Status: Uploading citation record ' + inttostr(X
              + 1) + ' of ' +
              inttostr(length(CitationArray)));
            GaugeProgress(X);
            PostData.Clear;
            PostData.Add('action=insert_citation');
            PostData.Add('table=' + MySQLCitationTbl);
            PostData.Add('factkey=' + CitationArray[X][0]);
            PostData.Add('srckey=' + CitationArray[X][1]);
            PostData.Add('source=' + CitationArray[X][2]);
            LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
              PostData);
            if LastResp < '0' then
            begin
              LastError := 'Error inserting into citation table at ' +
                CitationArray[X][0];
              exit;
            end;
            if AbortProc = True then
              exit;
          end;
          UpdateStatusLog('Uploaded ' + inttostr(length(CitationArray)) +
            ' citation records');
        end;

        { Create facts table }
        UpdateStatusLog('Creating fact table...');
        UpdateStatusBar(1, 'Status: Creating fact table...');
        PostData.Clear;
        PostData.Add('action=create_table_fact');
        PostData.Add('table=' + MySQLFactTbl);
        LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
          PostData);
        if LastResp <> '1' then
        begin
          LastError := 'Error creating facts table';
          exit;
        end;
        if AbortProc = True then
          exit;

        { Upload fact data }
        if length(FactArray) > 0 then
        begin
          UpdateStatusLog('Uploading fact records...');
          UpdateStatusBar(1, 'Status: Uploading fact records...');
          GaugeSetup(True, 0, length(FactArray));
          for X := 0 to length(FactArray) - 1 do
          begin
            UpdateStatusBar(1, 'Status: Uploading fact record ' + inttostr(X + 1)
              + ' of ' +
              inttostr(length(FactArray)));
            GaugeProgress(X);
            PostData.Clear;
            PostData.Add('action=insert_fact');
            PostData.Add('table=' + MySQLFactTbl);
            PostData.Add('indfamkey=' + FactArray[X][0]);
            PostData.Add('type=' + FactArray[X][1]);
            PostData.Add('date=' + FactArray[X][2]);
            PostData.Add('place=' + FactArray[X][3]);
            PostData.Add('factkey=' + FactArray[X][4]);
            LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
              PostData);
            if LastResp <> '1' then
            begin
              LastError := 'Error inserting into fact table at ' +
                FactArray[X][0];
              exit;
            end;
            if AbortProc = True then
              exit;
          end;
          UpdateStatusLog('Uploaded ' + inttostr(length(FactArray)) +
            ' fact records');
        end;

        { Create family table and upload data}
        UpdateStatusLog('Creating family table...');
        PostData.Clear;
        PostData.Add('action=create_table_family');
        PostData.Add('table=' + MySQLFamilyTbl);
        with frmMain.HTTP1 do
        begin
          LastResp := Post('http://' + HTTPServer + '/' + FncsFile, PostData);
          if LastResp <> '1' then
          begin
            LastError := 'Error creating family table';
            exit;
          end;
          if AbortProc = True then
            exit;
        end;

        { Upload family data }
        if length(FamArray) > 0 then
        begin
          UpdateStatusLog('Uploading family records...');
          UpdateStatusBar(1, 'Status: Uploading family records...');
          GaugeSetup(True, 0, length(FamArray));
          for X := 0 to length(FamArray) - 1 do
          begin
            UpdateStatusBar(1, 'Status: Uploading family record ' + inttostr(X +
              1) + ' of ' +
              inttostr(length(FamArray)));
            GaugeProgress(X);
            PostData.Clear;
            PostData.Add('action=insert_family');
            PostData.Add('table=' + MySQLFamilyTbl);
            PostData.Add('famkey=' + FamArray[X][0]);
            PostData.Add('spouse1=' + FamArray[X][1]);
            PostData.Add('spouse2=' + FamArray[X][2]);
            PostData.Add('beginstatus=' + FamArray[X][3]);
            PostData.Add('endstatus=' + FamArray[X][4]);
            PostData.Add('notekey=' + FamArray[X][5]);
            LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
              PostData);
            if LastResp <> '1' then
            begin
              LastError := 'Error inserting into family table at ' +
                FamArray[X][0];
              exit;
            end;
            if AbortProc = True then
              exit;
          end;
          UpdateStatusLog('Uploaded ' + inttostr(length(FamArray)) +
            ' family records');
        end;

        { Create indiv table and upload data}
        UpdateStatusLog('Creating individual table...');
        PostData.Clear;
        PostData.Add('action=create_table_indiv');
        PostData.Add('table=' + MySQLIndividualTbl);
        with frmMain.HTTP1 do
        begin
          LastResp := Post('http://' + HTTPServer + '/' + FncsFile, PostData);
          if LastResp <> '1' then
          begin
            LastError := 'Error creating individual table';
            exit;
          end;
          if AbortProc = True then
            exit;
        end;

        { Upload individual data }
        if length(IndivArray) > 0 then
        begin
          UpdateStatusLog('Uploading individual records...');
          UpdateStatusBar(1, 'Status: Uploading individual records...');
          GaugeSetup(True, 0, length(IndivArray));
          for X := 0 to length(IndivArray) - 1 do
          begin
            UpdateStatusBar(1, 'Status: Uploading individual record ' +
              inttostr(X + 1) + ' of ' +
              inttostr(length(IndivArray)));
            GaugeProgress(X);
            PostData.Clear;
            PostData.Add('action=insert_indiv');
            PostData.Add('table=' + MySQLIndividualTbl);
            PostData.Add('indkey=' + IndivArray[X][0]);
            PostData.Add('title=' + IndivArray[X][1]);
            PostData.Add('surname=' + IndivArray[X][2]);
            PostData.Add('givenname=' + IndivArray[X][3]);
            PostData.Add('aka=' + IndivArray[X][4]);
            PostData.Add('sex=' + IndivArray[X][5]);
            PostData.Add('notkey=' + IndivArray[X][6]);
            LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
              PostData);
            if LastResp <> '1' then
            begin
              LastError := 'Error inserting into individual table at ' +
                IndivArray[X][0];
              exit;
            end;
            if AbortProc = True then
              exit;
          end;
          UpdateStatusLog('Uploaded ' + inttostr(length(IndivArray)) +
            ' individual records');
        end;

        { Create note table and upload data}
        UpdateStatusLog('Creating individual table...');
        PostData.Clear;
        PostData.Add('action=create_table_note');
        PostData.Add('table=' + MySQLNoteTbl);
        with frmMain.HTTP1 do
        begin
          LastResp := Post('http://' + HTTPServer + '/' + FncsFile, PostData);
          if LastResp <> '1' then
          begin
            LastError := 'Error creating note table';
            exit;
          end;
          if AbortProc = True then
            exit;
        end;

        { Upload note data }
        if length(NoteArray) > 0 then
        begin
          UpdateStatusLog('Uploading note records...');
          UpdateStatusBar(1, 'Status: Uploading note records...');
          GaugeSetup(True, 0, length(NoteArray));
          for X := 0 to length(NoteArray) - 1 do
          begin
            UpdateStatusBar(1, 'Status: Uploading note record ' + inttostr(X + 1)
              + ' of ' +
              inttostr(length(NoteArray)));
            GaugeProgress(X);
            PostData.Clear;
            PostData.Add('action=insert_note');
            PostData.Add('table=' + MySQLNoteTbl);
            PostData.Add('notekey=' + NoteArray[X][0]);
            PostData.Add('text=' + NoteArray[X][1]);
            LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
              PostData);
            if LastResp <> '1' then
            begin
              LastError := 'Error inserting into note table at ' +
                NoteArray[X][0];
              exit;
            end;
            if AbortProc = True then
              exit;
          end;
          UpdateStatusLog('Uploaded ' + inttostr(length(NoteArray)) +
            ' note records');
        end;

        { Create relation table and upload data}
        UpdateStatusLog('Creating relation table...');
        PostData.Clear;
        PostData.Add('action=create_table_relation');
        PostData.Add('table=' + MySQLRelationTbl);
        with frmMain.HTTP1 do
        begin
          LastResp := Post('http://' + HTTPServer + '/' + FncsFile, PostData);
          if LastResp <> '1' then
          begin
            LastError := 'Error creating relation table';
            exit;
          end;
          if AbortProc = True then
            exit;
        end;

        { Upload relation data }
        if length(RelatArray) > 0 then
        begin
          UpdateStatusLog('Uploading relation records...');
          UpdateStatusBar(1, 'Status: Uploading relation records...');
          GaugeSetup(True, 0, length(RelatArray));
          for X := 0 to length(RelatArray) - 1 do
          begin
            UpdateStatusBar(1, 'Status: Uploading relation record ' + inttostr(X
              + 1) + ' of ' +
              inttostr(length(RelatArray)));
            GaugeProgress(X);
            PostData.Clear;
            PostData.Add('action=insert_relation');
            PostData.Add('table=' + MySQLRelationTbl);
            PostData.Add('indkey=' + RelatArray[X][0]);
            PostData.Add('famkey=' + RelatArray[X][1]);
            LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
              PostData);
            if LastResp <> '1' then
            begin
              ShowMessage(LastResp);
              LastError := 'Error inserting into relation table at ' +
                RelatArray[X][0];
              exit;
            end;
            if AbortProc = True then
              exit;
          end;
          UpdateStatusLog('Uploaded ' + inttostr(length(RelatArray)) +
            ' relation records');
        end;

        { Create source table and upload data}
        UpdateStatusLog('Creating source table...');
        PostData.Clear;
        PostData.Add('action=create_table_source');
        PostData.Add('table=' + MySQLSourceTbl);
        with frmMain.HTTP1 do
        begin
          LastResp := Post('http://' + HTTPServer + '/' + FncsFile, PostData);
          if LastResp <> '1' then
          begin
            LastError := 'Error creating source table';
            exit;
          end;
          if AbortProc = True then
            exit;
        end;

        { Upload source data }
        if length(SourceArray) > 0 then
        begin
          UpdateStatusLog('Uploading source records...');
          UpdateStatusBar(1, 'Status: Uploading source records...');
          GaugeSetup(True, 0, length(SourceArray));
          for X := 0 to length(SourceArray) - 1 do
          begin
            UpdateStatusBar(1, 'Status: Uploading source record ' + inttostr(X +
              1) + ' of ' +
              inttostr(length(SourceArray)));
            GaugeProgress(X);
            PostData.Clear;
            PostData.Add('action=insert_source');
            PostData.Add('table=' + MySQLSourceTbl);
            PostData.Add('srckey=' + SourceArray[X][0]);
            PostData.Add('text=' + SourceArray[X][1]);
            PostData.Add('notekey=' + SourceArray[X][2]);
            LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
              PostData);
            if LastResp <> '1' then
            begin
              LastError := 'Error inserting into source table at ' +
                SourceArray[X][0];
              exit;
            end;
            if AbortProc = True then
              exit;
          end;
          UpdateStatusLog('Uploaded ' + inttostr(length(SourceArray)) +
            ' relation records');
        end;

        { Create child table and upload data}
        UpdateStatusLog('Creating child table...');
        PostData.Clear;
        PostData.Add('action=create_table_child');
        PostData.Add('table=' + MySQLChildTbl);
        with frmMain.HTTP1 do
        begin
          LastResp := Post('http://' + HTTPServer + '/' + FncsFile, PostData);
          if LastResp <> '1' then
          begin
            LastError := 'Error creating child table';
            exit;
          end;
          if AbortProc = True then
            exit;
        end;

        { Upload child data }
        if length(ChildArray) > 0 then
        begin
          UpdateStatusLog('Uploading child records...');
          UpdateStatusBar(1, 'Status: Uploading child records...');
          GaugeSetup(True, 0, length(ChildArray));
          for X := 0 to length(ChildArray) - 1 do
          begin
            UpdateStatusBar(1, 'Status: Uploading child record ' + inttostr(X +
              1) + ' of ' +
              inttostr(length(ChildArray)));
            GaugeProgress(X);
            PostData.Clear;
            PostData.Add('action=insert_child');
            PostData.Add('table=' + MySQLChildTbl);
            PostData.Add('famkey=' + ChildArray[X][0]);
            PostData.Add('indkey=' + ChildArray[X][1]);
            LastResp := HTTP1.Post('http://' + HTTPServer + '/' + FncsFile,
              PostData);
            if LastResp <> '1' then
            begin
              UpdateStatusLog(LastResp);
              LastError := 'Error inserting into child table at ' +
                ChildArray[X][0];
              exit;
            end;
            if AbortProc = True then
              exit;
          end;
          UpdateStatusLog('Uploaded ' + inttostr(length(ChildArray)) +
            ' child records');
        end;

        { Connect to FTP server and change directory }
        UpdateStatusLog('Connecting to ' + FTPServer + '...');
        UpdateStatusBar(1, 'Status: Connecting to ' + FTPServer + '...');
        FTP.Connect(True);
        if AbortProc = True then
          exit;
        if FTPPath <> '' then
        begin
          UpdateStatusLog('Changing directory to ' + FTPPath + '...');
          UpdateStatusBar(1, 'Status: Changing directory to ' + FTPPath +
            '...');
          ChangeDir(FTPPath);
        end;
        if AbortProc = True then
          exit;

        { Delete script and data files }
        UpdateStatusLog('Deleting ' + VarsFile + '...');
        UpdateStatusBar(1, 'Status: Deleting ' + VarsFile + '...');
        Delete(VarsFile);
        if AbortProc = True then
          exit;
        UpdateStatusLog('Deleting ' + FncsFile + '...');
        UpdateStatusBar(1, 'Status: Deleting ' + FncsFile + '...');
        Delete(FncsFile);
        if AbortProc = True then
          exit;
        FTP.Disconnect;
      except
        on EidProtocolReplyError do
          LastError := LastCmdResult.Text[0];
      end;
    finally
      GaugeSetup(False);
      if Connected = True then
      begin
        UpdateStatusLog('Disconnecting from ' + FTPServer + '...');
        UpdateStatusBar(1, 'Status: Disconnecting from ' + FTPServer + '...');
        Disconnect;
      end;
      if LastError <> '' then
      begin
        UpdateStatusLog(LastError);
      end
      else if AbortProc = True then
      begin
        AbortProc := False;
        UpdateStatusLog('Process aborted.');
      end
      else
        UpdateStatusLog('Successfully uploaded all data.');
      UpdateStatusBar(1, 'Status:');
      btnAbort.Visible := False;
      PostData.Free;
      Vars.Free;
    end;
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure TfrmMain.btnAbortClick(Sender: TObject);
begin
  UpdateStatusLog('Aborting current process...');
  AbortProc := True;
end;

{ ---------------------------------------------------------------------------- }

end.

